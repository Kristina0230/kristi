                                                    **Динамические структуры данных**
                                                    
                                                    
                                                    
        ** СОДЕРЖАНИЕ**

ВВЕДЕНИЕ
1. Теоретические сведения
2. Разработка
Заключение


---------------------------------------------------------------------------------------------------------------------------------------------------------

**Введение**
Данная программа была разработана для изучения динамических структур данных таких, как стек, очередь и список. Применение их для решения практических 
задач. Создание графического интерфейса.На сегодняшний день существует много средств для визуального проектирования программ, наиболее известные из них: 
Visual Studio (последняя версия 10.0) Borland C++ Builder. В основе этих сред программирования лежит технология визуального проектирования и событийного 
программирования, суть которой заключаетсяв том, что среда разработки берет на себя большую часть работы по генерации кода программы, оставляя автору работу 
по конструированию диалоговых окон и написа­нию функций обработки событий, благодаря этому скорость разработки программ возрастает.


------------------------------------------------------------------------------------------------------------------------------------------------------------

                                                              **1. Теоретические сведения**

                                                              **Динамические структуры данных**

Часто в серьезных программах надо использовать данные, размер и структура которых должны меняться в процессе работы. Динамические массивы здесь не выручают,
поскольку заранее нельзя сказать, сколько памяти надо выделить – это выясняется только в процессе рабо- ты. Например, надо проанализировать текст и 
определить, какие слова и в каком количество в нем встречаются, причем эти слова нужно расставить по алфавиту.
В таких случаях применяют данные особои? структуры, которые представляют собои? отдельные элементы, связанные с помощью ссылок. Каждыи? элемент (узел) 
состоит из двух областеи? памяти: поля данных и ссылок. Ссылки – это адреса других узлов этого же типа, с которыми дан- ныи? элемент логически связан.
В языке Си для организации ссылок используются переменные- указатели. При добавлении нового узла в такую структуру выделяется новыи? блок памяти и
(с помощью ссылок) устанавливаются связи этого элемента с уже существующими. Для обозна- чения конечного элемента в цепи используются нулевые
ссылки (NULL).

Всего существует 6 основных видов динамических структур данных :
*Стек*
*Очередь*
*Хэш таблица*
*Список (односвязный, двусвязный, циклический)*
*Дерево*
*Граф*
Список

**Существует 3 вида списков :**
*односвязный (линейный)*
*двусвязный*
*циклический*

**Односвязный список** похож на очередь, но в отличии от нее при работе со списком можно добавлять элемент в любое его место и при этом испольуется всего
один указатель на начало списка.

**Двусвязный список.**
Многие проблемы при работе с односвязным списком вызваны тем, что в них невозможно переи?ти к предыдущему элементу. Возникает естественная идея – хранить 
в памяти ссылку не только на следующии?, но и на предыдущии элемент списка. Для доступа к списку используется не одна переменная-указатель, а две – 
ссылка на «голову» списка (Head) и на «хвост» - последнии 
элемент (Tail).


**Очередь**

Очередь – это упорядоченныи набор элементов, в котором добавление новых элементов допустимо с одного конца (он называется начало очереди), а удаление
существующих элементов – только с другого конца, которыи называется концом очереди.Хорошо знакомои моделью является очередь в магазине. Очередь называют
структурои? типа FIFO (First In – First Out) – первым пришел, первым ушел. 

**Стек**
Стек – это упорядоченныи набор элементов, в котором добавление новых и удаление существующих элементов допустимо только с одного конца, которыи 
называется вершинои стека. Стек называют структурои типа LIFO (Last In – First Out) – последним пришел, первым ушел. Стек похож на стопку с подносами, 
уложенными один на другои – чтобы достать какои?-то под- нос надо снять все подносы, которые лежат на нем, а положить новыи? поднос можно только сверху
всеи стопки. 
В современных компьютерах стек используется для :
*размещения локальных переменных*
*размещения параметров процедуры или функции*
*сохранения адреса возврата (по какому адресу надо вернуться из процедуры)*
*временного хранения данных, особенно при программировании на Ассемблере*

На стек выделяется ограниченная область памяти. При каждом вызове процедуры в стек добавляются новые элементы (параметры, локальные переменные, адрес 
возврата). Поэтому если вложенных вызовов будет много, стек переполнится. Очень опаснои в отношении переполнения стека является рекурсия, поскольку она
как раз и предполагает вложенные вызовы однои и тои же процедуры или функции. При ошибке в программе рекурсия может стать бесконечнои, кроме того, стек
может переполниться, если вложенных вызовов будет слишком много.
--------------------------------------------------------------------------------------------------------------------------------------------------------

                                                                      ** 2. Разработка**
                                                                       
В этом разделе будутпоследовательно рассмотрены процедуры (методы), работающие с данной структурой(стеком). Входные значения процедур вводятся с
клавиатуры посредствам различныхдиалоговых окон с помощью программного продукта Builder C++.

Ниже приведена сама структура:

***struct tStack

{

char strFName [255]; // имяфункции

char strRValue [6]; // возвращаемоезначение

int numPar; // количествовведених параметров

char** pParams; // указатель на парамаетры

bool bFilled; // заполнен ли элемент

tStack* pNext; // указатель на следующий элемент

tStack ()

{

pNext = NULL; // задаём начальные параметры стека, что он пуст

numPar = 0;

bFilled = false;

}

void Add (char*strFName_, char* strRValue_, int numPar_, char** pParams_);

void Delete ();

void Print (TMemo*memo);

void Free ();

};

strFName — поле, хранящее имя функции;

strRValue — поле, хранящее возвращаемое значение;

numParams — поле, хранящее количество параметров;

pRarams — поле указателя, хранящего адресс значений параметров;

Далее приведены описания процедур:

void Add (char*strFName_, char* strRValue_, int numPar_, char** pParams_);

void Delete ();

void Print (TMemo*memo);

void Free ().***

                                                           **2.1 Процедура добавленияэлемента**
Ниже приведен код процедурыдобавления элемента в стек:

***tStack* temp; // создаём указатель temp типа tStack

int num = 0; // количество элементов 0

int max_num =1000; // максимальное количество элементов равно 1000

void tStack:: Add(char* strFName_, char* strRValue_, int numPar_, char** pParams_)

{

if (num == (max_num-1))MessageBox («Almost Overload», «Warning », MB_OK);// если элементов на единицу меньше максимального количества элементов,программа предупредит диалоговым окном

if (num == max_num)// если элементов максимальное количество

{

MessageBox(«Overload», "", «Error», MB_OK);// диалоговое окно с ошибкой

return;// процедура добавления элемента останавливается

}

num++;// счетчик количества введенных элементов

if (pNext) // если есть ссылка на следующий элемент

pNext->Add (strFName_, strRValue_,numPar_, pParams_); // добавляемэлемент с адресом pNext

else

{

if (! bFilled) // если элемент заполнен

{

strcpy (strFName, strFName_); // копируемзначения строк из одной переменной в другую

strcpy (strRValue,strRValue_);

numPar =numPar_;

pParams = newchar* [numPar] ;

for (int i = 0;i < numPar; i++) // повторяем цикл numPar раз

{

pParams[i] = new char [6]; // выделяем память для хранения одного параметра 6байт из массива

strncpy (pParams[i], pParams_ [i],

6); // копируем значения из введённых,отсекая всё больше 6-ти байт

}

bFilled= true; // поле считается заполненным

}

else

{

pNext = new tStack;// выделяем память под новые элемент tStack

pNext->Add (strFName_,strRValue_, numPar_, pParams_); // добавляем элемент

}

}

}
***
В этой функции реализована ипроверка на переполнение стека. Проверка переполнения выполняется по количествувведенных элементов int max_num = 1000; и
счётчику текущегоэлемента num:

if (num == (max_num-1))MessageBox («Almost Overload», «Warning », MB_OK);// если элементов на единицу меньше максимального количества элементов,программа 
предупредит диалоговым окном

if (num == max_num)// если элементов максимальное количество

{

MessageBox(«Overload», "", «Error», MB_OK);// диалоговое окно с ошибкой

return;// процедура добавления элемента останавливается

}

num++;// счетчик количества введенных элементов

Реализация ввода параметров (поопределенному введенному количеству) выполнена через массив указателей.

Входные параметры поступают изметодов С++ Builder через поля и кнопки исполнения. Выходногозначения нету.
